{"ast":null,"code":"import { LABEL_PADDING_HORIZONTAL, ADORNMENT_OFFSET, ADORNMENT_SIZE, FLAT_INPUT_OFFSET } from \"./constants\";\nimport { AdornmentType, AdornmentSide } from \"./Adornment/enums\";\nexport var calculateLabelTopPosition = function calculateLabelTopPosition(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var optionalPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var customHeight = height > 0 ? height : 0;\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\nexport var calculateInputHeight = function calculateInputHeight(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var minHeight = arguments.length > 2 ? arguments[2] : undefined;\n  var finalHeight = height > 0 ? height : labelHeight;\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\nexport var calculatePadding = function calculatePadding(props) {\n  var height = props.height,\n    _props$multiline = props.multiline,\n    multiline = _props$multiline === void 0 ? false : _props$multiline;\n  var result = 0;\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n  return Math.max(0, result);\n};\nvar calculateTextAreaPadding = function calculateTextAreaPadding(props) {\n  var dense = props.dense;\n  return dense ? 10 : 20;\n};\nvar calculateInputPadding = function calculateInputPadding(_ref) {\n  var topPosition = _ref.topPosition,\n    fontSize = _ref.fontSize,\n    multiline = _ref.multiline,\n    scale = _ref.scale,\n    dense = _ref.dense,\n    offset = _ref.offset,\n    isAndroid = _ref.isAndroid;\n  var refFontSize = scale * fontSize;\n  var result = Math.floor(topPosition / 2);\n  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);\n  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);\n  return result;\n};\nexport var adjustPaddingOut = function adjustPaddingOut(_ref2) {\n  var pad = _ref2.pad,\n    multiline = _ref2.multiline,\n    label = _ref2.label,\n    scale = _ref2.scale,\n    height = _ref2.height,\n    fontSize = _ref2.fontSize,\n    lineHeight = _ref2.lineHeight,\n    dense = _ref2.dense,\n    offset = _ref2.offset,\n    isAndroid = _ref2.isAndroid;\n  var fontHeight = lineHeight !== null && lineHeight !== void 0 ? lineHeight : fontSize;\n  var refFontHeight = scale * fontSize;\n  var result = pad;\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2)\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight / 2 * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight * scale) : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return {\n    paddingTop: result,\n    paddingBottom: result\n  };\n};\nexport var adjustPaddingFlat = function adjustPaddingFlat(_ref3) {\n  var pad = _ref3.pad,\n    scale = _ref3.scale,\n    multiline = _ref3.multiline,\n    label = _ref3.label,\n    height = _ref3.height,\n    offset = _ref3.offset,\n    dense = _ref3.dense,\n    fontSize = _ref3.fontSize,\n    isAndroid = _ref3.isAndroid,\n    styles = _ref3.styles;\n  var result = pad;\n  var topResult = result;\n  var bottomResult = result;\n  var paddingTop = styles.paddingTop,\n    paddingBottom = styles.paddingBottom;\n  var refFontSize = scale * fontSize;\n  if (!multiline) {\n    if (label) {\n      return {\n        paddingTop: paddingTop,\n        paddingBottom: paddingBottom\n      };\n    }\n    return {\n      paddingTop: result,\n      paddingBottom: result\n    };\n  }\n  if (label) {\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n    if (!isAndroid) {\n      if (dense) {\n        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2)\n      };\n    }\n    if (!isAndroid) {\n      if (dense) {\n        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);\n      }\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult)\n  };\n};\nexport var interpolatePlaceholder = function interpolatePlaceholder(labeled, hasActiveOutline) {\n  return labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1]\n  });\n};\nexport function calculateFlatAffixTopPosition(_ref4) {\n  var height = _ref4.height,\n    paddingTop = _ref4.paddingTop,\n    paddingBottom = _ref4.paddingBottom,\n    affixHeight = _ref4.affixHeight;\n  var inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n  var halfOfTheInputHeightDecreasedByAffixHeight = (inputHeightWithoutPadding - affixHeight) / 2;\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\nexport function calculateOutlinedIconAndAffixTopPosition(_ref5) {\n  var height = _ref5.height,\n    affixHeight = _ref5.affixHeight,\n    labelYOffset = _ref5.labelYOffset;\n  return (height - affixHeight + labelYOffset) / 2;\n}\nexport var calculateFlatInputHorizontalPadding = function calculateFlatInputHorizontalPadding(_ref6) {\n  var adornmentConfig = _ref6.adornmentConfig;\n  var paddingLeft = LABEL_PADDING_HORIZONTAL;\n  var paddingRight = LABEL_PADDING_HORIZONTAL;\n  adornmentConfig.forEach(function (_ref7) {\n    var type = _ref7.type,\n      side = _ref7.side;\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n  return {\n    paddingLeft: paddingLeft,\n    paddingRight: paddingRight\n  };\n};","map":{"version":3,"sources":["/Users/saeb_97/Desktop/behavior-dev-team/frontend/node_modules/react-native-paper/lib/module/components/TextInput/helpers.tsx"],"names":["LABEL_PADDING_HORIZONTAL","ADORNMENT_OFFSET","ADORNMENT_SIZE","FLAT_INPUT_OFFSET","AdornmentType","AdornmentSide","calculateLabelTopPosition","labelHeight","height","optionalPadding","customHeight","Math","floor","calculateInputHeight","minHeight","finalHeight","calculatePadding","props","multiline","result","calculateTextAreaPadding","calculateInputPadding","max","dense","topPosition","fontSize","scale","offset","isAndroid","refFontSize","min","adjustPaddingOut","pad","label","lineHeight","fontHeight","refFontHeight","paddingTop","paddingBottom","adjustPaddingFlat","styles","topResult","bottomResult","interpolatePlaceholder","labeled","hasActiveOutline","interpolate","inputRange","outputRange","calculateFlatAffixTopPosition","affixHeight","inputHeightWithoutPadding","halfOfTheInputHeightDecreasedByAffixHeight","calculateOutlinedIconAndAffixTopPosition","labelYOffset","calculateFlatInputHorizontalPadding","adornmentConfig","paddingLeft","paddingRight","forEach","type","side","Icon","Left","Right","Affix"],"mappings":"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","sourcesContent":["import type { Animated } from 'react-native';\nimport type { AdornmentConfig } from './Adornment/types';\nimport {\n  LABEL_PADDING_HORIZONTAL,\n  ADORNMENT_OFFSET,\n  ADORNMENT_SIZE,\n  FLAT_INPUT_OFFSET,\n} from './constants';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\nimport type { TextInputLabelProp } from './types';\n\ntype PaddingProps = {\n  height: number | null;\n  labelHalfHeight: number;\n  multiline: boolean | null;\n  dense: boolean | null;\n  topPosition: number;\n  fontSize: number;\n  lineHeight?: number;\n  label?: TextInputLabelProp | null;\n  scale: number;\n  offset: number;\n  isAndroid: boolean;\n  styles: { paddingTop: number; paddingBottom: number };\n};\n\ntype AdjProps = PaddingProps & {\n  pad: number;\n};\n\nexport type Padding = { paddingTop: number; paddingBottom: number };\n\nexport const calculateLabelTopPosition = (\n  labelHeight: number,\n  height: number = 0,\n  optionalPadding: number = 0\n): number => {\n  const customHeight = height > 0 ? height : 0;\n\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\n\nexport const calculateInputHeight = (\n  labelHeight: number,\n  height: any = 0,\n  minHeight: number\n): number => {\n  const finalHeight = height > 0 ? height : labelHeight;\n\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\n\nexport const calculatePadding = (props: PaddingProps): number => {\n  const { height, multiline = false } = props;\n\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = (props: PaddingProps) => {\n  const { dense } = props;\n\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid,\n}: PaddingProps): number => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n\n  result =\n    result +\n    Math.floor((refFontSize - fontSize) / 2) -\n    (scale < 1 ? offset / 2 : 0);\n\n  if (multiline && isAndroid)\n    result = Math.min(dense ? offset / 2 : offset, result);\n\n  return result;\n};\n\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  lineHeight,\n  dense,\n  offset,\n  isAndroid,\n}: AdjProps): Padding => {\n  const fontHeight = lineHeight ?? fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2),\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, (refFontHeight / 2) * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result +=\n          scale < 1\n            ? Math.min(offset, refFontHeight * scale)\n            : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return { paddingTop: result, paddingBottom: result };\n};\n\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles,\n}: AdjProps): Padding => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const { paddingTop, paddingBottom } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return { paddingTop, paddingBottom };\n    }\n    // return pad for flat input without label\n    return { paddingTop: result, paddingBottom: result };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    // adjust top padding for iOS\n    if (!isAndroid) {\n      if (dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(result, refFontSize * scale) - result / 2\n            : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(offset / 2, refFontSize * scale)\n            : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2),\n      };\n    }\n    // adjust paddings for iOS if no label\n    if (!isAndroid) {\n      if (dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset / 2, (fontSize / 2) * scale)\n            : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset, fontSize * scale)\n            : Math.min(fontSize, (offset / 2) * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult),\n  };\n};\n\nexport const interpolatePlaceholder = (\n  labeled: Animated.Value,\n  hasActiveOutline: boolean | undefined\n) =>\n  labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1],\n  });\n\nexport function calculateFlatAffixTopPosition({\n  height,\n  paddingTop,\n  paddingBottom,\n  affixHeight,\n}: {\n  height: number;\n  paddingTop: number;\n  paddingBottom: number;\n  affixHeight: number;\n}): number {\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n\n  const halfOfTheInputHeightDecreasedByAffixHeight =\n    (inputHeightWithoutPadding - affixHeight) / 2;\n\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\n\nexport function calculateOutlinedIconAndAffixTopPosition({\n  height,\n  affixHeight,\n  labelYOffset,\n}: {\n  height: number;\n  affixHeight: number;\n  labelYOffset: number;\n}): number {\n  return (height - affixHeight + labelYOffset) / 2;\n}\n\nexport const calculateFlatInputHorizontalPadding = ({\n  adornmentConfig,\n}: {\n  adornmentConfig: AdornmentConfig[];\n}) => {\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n\n  adornmentConfig.forEach(({ type, side }) => {\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n\n  return { paddingLeft, paddingRight };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}